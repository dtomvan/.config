// assumption: bx_if_eq and bx_if_not_eq both work
// Testing framework starts here

bx_if_eq _can_test 0 echo ^3Warning: you didnt _endall_ your tests.
set testing_func "NOT_TESTING"
set _can_test 0
set _testing_success 0

alias do "bx_if ${_testing_success} ${1-}"

alias cannot_test "echo All tests have concluded. Cannot test anymore."

alias assert "bx_if_not ${$1} assertion_failed ${1-}"
alias assert_eq "bx_if_not_eq ${$1} ${$2} assertion_failed ${1} (${$1}) == ${2} (${$2}): ${3-}"
alias assertion_failed "bx_if ${_can_test} _assertion_failed ${1-}; bx_if_not ${_can_test} cannot_test"
alias _assertion_failed "echo Assertion failed: ${1-}; _testing_success 0"

alias start "bx_if ${_can_test} _start ${1-}; bx_if_not ${_can_test} cannot_test"
alias _start "test_should_be_closed; echo ---; echo ^2Testing function ${1}; set testing_func ${1}; _testing_success 1"
alias it "bx_if ${_can_test} _it ${1-}; bx_if_not ${_can_test} cannot_test"
alias _it "test_should_have_started; echo it ${1-}"
alias s "bx_if ${testing_verbose ?} echo ${1} = ${2}; set ${1} ${2}"

alias startall "bx_if ${_can_test} spurious_startall; bx_if_not ${_can_test} _startall"
alias _startall "_can_test 1; echo ==========; echo ==========; echo Started testing"
alias spurious_startall "^3Warning: startall was called twice"
alias end "test_should_have_started; evaluate_test; echo ---; testing_func NOT_TESTING; _testing_success 0"
alias endall "echo ^4Done testing; echo ==========; echo ==========; _can_test 0; test_should_be_closed"
alias evaluate_test "bx_if ${_testing_success} echo ^4Done testing function ${testing_func}; bx_if_not ${_testing_success} echo ^1Testing function ${testing_func} failed"
alias test_should_have_started "bx_if_eq ${testing_func} NOT_TESTING echo ^3Warning: you didn't specify a testing_func. Call start first."
alias test_should_be_closed "bx_if_not_eq ${testing_func} NOT_TESTING echo ^3Warning: you didn't end the ${testing_func} test."

// Actual tests start here
startall

alias tester "s in ${1}; set out ${1}; s expected ${2}; ${testing_func} out; test_${testing_func}_step2 ${1-}"

start bx_inc
it increments a number
alias test_bx_inc_step2 "assert_eq out expected in should be incremented by 1, ${1} + 1 should be ${2}"
do tester 0 1
do tester 1 2
do tester 2 3
do tester 3 4
do tester 4 5
do tester 5 6
do tester 99999 100000
end

start bx_dec
it decrements a number
alias test_bx_dec_step2 "assert_eq out expected in should be decremented by 1, ${1} - 1 should be ${2}"
do tester 1 0
do tester 2 1
do tester 3 2
do tester 4 3
do tester 5 4
do tester 6 5
do tester 100000 99999
end

// Tests a gate (2 inputs, 1 expected value)
alias gate "set out \"\"; s in_1 ${1}; s in_2 ${2}; s expected ${3}; gate_step2 ${1-}"
alias gate_step2 "${testing_func} ${in_1} ${in_2} out; test_${testing_func}_step2 ${1-}"
start bx_or
it checks if either of the inputs are 1
alias test_bx_or_step2 "assert_eq out expected bx_or should return in_1 | in_2, ${1} | ${2} should be ${3}"
do gate 0 0 0
do gate 1 0 1
do gate 0 1 1
do gate 1 1 1
end

start bx_nand
it checks if both inputs arent 1
alias test_bx_nand_step2 "assert_eq out expected bx_nand should return in_1 NAND in_2, ${1} NAND ${2} should be ${3}"
do gate 0 0 1
do gate 1 0 1
do gate 0 1 1
do gate 1 1 0
end

start bx_and
it checks if both inputs are 1
alias test_bx_and_step2 "assert_eq out expected bx_and should return in_1 & in_2, ${1} & ${2} should be ${3}"
do gate 0 0 0
do gate 1 0 0
do gate 0 1 0
do gate 1 1 1
end

alias rot "s in_1 ${1}; s in_2 ${2}; s in_3 ${3}; s out_1 ${4}; s out_2 ${5}; s out_3 ${6}; rot_step2 ${1-}"
alias rot_step2 "${testing_func} in_1 in_2 in_3; rot_step3 ${1-}"
alias rot_step3 "set rot_error \"bx_rot should rotate in_1, in_2 and in_3, ${1} ${2} ${3} ROT should be ${4} ${5} ${6}\"; rot_step4"
alias rot_step4 "assert_eq in_1 out_1 ${rot_error}; assert_eq in_2 out_2 ${rot_error}; assert_eq in_3 out_3 ${rot_error}"
start bx_rot
it rotates 3 values (rpn exch on steroids)
do rot 0 0 0 0 0 0
do rot 1 2 3 2 3 1
do rot 2 3 1 3 1 2
do rot 3 1 2 1 2 3
do rot 10 11 12 11 12 10
do rot 100 100 100 100 100 100
end

endall

// vim:ft=bash:tw=0
